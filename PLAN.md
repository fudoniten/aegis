# Aegis - Encrypted Secrets Management for NixOS

## Overview

Aegis replaces the unencrypted `fudo-secrets` monorepo with an encrypted system where:
- All secrets encrypted with **age** (no agenix dependency - custom NixOS module)
- Public repos are safe (encryption, not obscurity)
- Users manage secrets in their own repos, consolidated by admin
- Build servers never see plaintext secrets

## Key Design Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Encryption | age (direct) | Simple, auditable, no wrapper complexity |
| NixOS integration | Custom `aegis.secrets` module | Full control, testable, models `fudo.secrets` |
| Tools language | Python | Type safety, testing, better UX than bash |
| Repo visibility | Public | Encrypted secrets are safe |
| CLI semantics | `make-*` = generate, `add-*` = user provides | Clear intent |
| User secrets | Separate repos, consolidated by admin | Users own their repos, admin controls deployment |

## Repository Structure

```
aegis/                      # NixOS module (this repo)
aegis-tools-system/         # Admin CLI tools
aegis-tools-user/           # User CLI tools  
aegis-secrets/              # Master secrets repo (admin-controlled)
  hosts/<hostname>/
  domains/<domain>/
  roles/
  users/<username>/         # Consolidated from user repos
  .user-keys/               # Private keys for decrypting user repos
aegis-secrets-<username>/   # Per-user repos (user-controlled)
  env/
  files/
```

### Workflow

```
1. Admin: aegis add-user niten --hosts=nostromo,legatus
   -> Generates keypair
   -> Stores private key in aegis-secrets/.user-keys/niten.age
   -> Outputs public key for user
   -> Adds user repo as flake input

2. User: aegis-user init --key=age1abc...
   -> Stores public key in aegis-secrets-niten/.key

3. User: aegis-user add-env GITHUB_TOKEN ghp_xxx
   -> Encrypts with stored public key
   -> Commits to aegis-secrets-niten/env/GITHUB_TOKEN.age

4. Admin: nix flake update
   -> Pulls latest from all user repos and other inputs

5. Admin: aegis build
   -> Decrypts user secrets with .user-keys/*
   -> Generates any missing system secrets (SSH, Kerberos, Nexus, etc.)
   -> Produces host-targeted bundles in build/hosts/<hostname>/
   -> Commits everything

6. Deploy: build servers use committed bundles
```

The `aegis build` step is a "compile" phase that transforms source secrets into
deployment-ready, host-targeted bundles. Users can keep their own local copies
however they want - the user repo is just input to the build.

## Architecture

```
Admin Workstation                    Target Host
-----------------                    -----------
aegis-tools                          aegis.secrets module
    |                                     |
    v                                     v
aegis-secrets/                       Phase 1: Decrypt with master-key
  hosts/nostromo/                         - host secrets
    ssh-keys.age    ───deploy───>         - role keys (if applicable)
    keytab.age                            - user deployment keys
  roles/                                  |
    kdc.age                               v
  users/niten/                       Phase 2: Decrypt with role/user keys
    env.age                               - role-specific secrets
                                          - user secrets
                                          |
                                          v
                                     Services/users get secrets
```

## Key Types

### 1. Host Master Key
- **Purpose**: Decrypt all host-scoped secrets
- **Generation**: Manual by admin (`ssh-keygen -t ed25519`)
- **Storage**: On host at path in entities; public key in `nix-entities`
- **Never generated by tools**

### 2. Host SSH Keys  
- **Purpose**: SSH daemon identification
- **Generation**: `aegis make-host-ssh-keys <hostname>`
- **Encryption**: Host master-key + admin key

### 3. Role Keys
- **Purpose**: Cross-host access (KDC reads all keytabs, DNS reads DNSSEC)
- **Generation**: `aegis make-role-key <role> <hostname>`
- **Encryption**: Role-holder's master-key + admin key

### 4. User Keys (Two-Layer System)
**User Repo Key** (for user repo -> central repo):
- **Purpose**: User encrypts secrets in their repo; admin decrypts to consolidate
- **Generation**: `aegis add-user <username> --hosts=...`
- **Private key**: Stored in `aegis-secrets/.user-keys/<username>.age` (encrypted for admin)
- **Public key**: Given to user, stored in their repo

**User Deployment Key** (for central repo -> hosts):
- **Purpose**: Decrypt consolidated user secrets on target hosts  
- **Generation**: Created alongside user repo key
- **Private key**: Encrypted for target hosts in `aegis-secrets/users/<username>/.key.age`
- **Used by**: Phase 2 decryption on hosts

### 5. Admin Key
- **Purpose**: Admin can decrypt/edit all secrets
- **Storage**: `~/.config/aegis/key.txt`

## NixOS Module: aegis.secrets

Modeled on your existing `fudo.secrets` but fresh implementation:

```nix
{ config, lib, pkgs, ... }:

let
  cfg = config.aegis.secrets;
  hostname = config.instance.hostname;
in {
  options.aegis.secrets = {
    enable = lib.mkEnableOption "Aegis secrets";
    
    secrets-path = lib.mkOption {
      type = lib.types.path;
      description = "Path to aegis-secrets repo";
    };
    
    host-secrets = lib.mkOption {
      type = lib.types.attrsOf (lib.types.submodule secretOpts);
      description = "Secrets for this host";
      default = {};
    };
    
    user-secrets = lib.mkOption {
      type = lib.types.attrsOf (lib.types.attrsOf (lib.types.submodule userSecretOpts));
      description = "Per-user secrets";
      default = {};
    };
    
    roles = lib.mkOption {
      type = lib.types.listOf lib.types.str;
      description = "Roles this host has (e.g., kdc, dns)";
      default = [];
    };
  };

  config = lib.mkIf cfg.enable {
    # Phase 1 target - host secrets decrypted
    systemd.targets.aegis-phase1 = {
      description = "Aegis phase 1 secrets available";
      wantedBy = [ "multi-user.target" ];
    };
    
    # Phase 2 target - role/user secrets decrypted  
    systemd.targets.aegis-phase2 = {
      description = "Aegis phase 2 secrets available";
      wantedBy = [ "multi-user.target" ];
      after = [ "aegis-phase1.target" ];
    };
    
    # Secret decryption services generated from host-secrets
    systemd.services = generateSecretServices cfg;
  };
}
```

### Secret Options (per secret)

```nix
secretOpts = { name, ... }: {
  options = {
    source-file = lib.mkOption {
      type = lib.types.path;
      description = "Encrypted .age file";
    };
    
    target-file = lib.mkOption {
      type = lib.types.str;
      description = "Where to decrypt on host";
    };
    
    user = lib.mkOption {
      type = lib.types.str;
      default = "root";
    };
    
    group = lib.mkOption {
      type = lib.types.str;
      default = "root";
    };
    
    permissions = lib.mkOption {
      type = lib.types.str;
      default = "0400";
    };
    
    phase = lib.mkOption {
      type = lib.types.enum [ 1 2 ];
      default = 1;
      description = "Decryption phase (1=master-key, 2=role/user key)";
    };
    
    identity = lib.mkOption {
      type = lib.types.nullOr lib.types.str;
      default = null;
      description = "Path to decryption key (null=master-key)";
    };
  };
};
```

### Decryption Service Template

```nix
mkSecretService = hostname: name: opts: {
  description = "Decrypt ${name} for ${hostname}";
  wantedBy = [ "aegis-phase${toString opts.phase}.target" ];
  before = [ "aegis-phase${toString opts.phase}.target" ];
  after = if opts.phase == 1 
    then [ "local-fs.target" ] 
    else [ "aegis-phase1.target" ];
  
  serviceConfig = {
    Type = "oneshot";
    RemainAfterExit = true;
    ExecStartPre = mkPrepScript opts;
    ExecStart = mkDecryptScript name opts;
    ExecStop = pkgs.writeShellScript "remove-${name}" "rm -f ${opts.target-file}";
  };
};

mkDecryptScript = name: opts: pkgs.writeShellScript "decrypt-${name}" ''
  IDENTITY="${if opts.identity == null 
    then config.aegis.secrets.master-key-path 
    else opts.identity}"
  
  rm -f ${opts.target-file}
  ${pkgs.age}/bin/age -d -i "$IDENTITY" -o ${opts.target-file} ${opts.source-file}
  chown ${opts.user}:${opts.group} ${opts.target-file}
  chmod ${opts.permissions} ${opts.target-file}
'';
```

## CLI Tools

Two tool repos: `aegis-tools-system` (admin) and `aegis-tools-user` (users).

### aegis-tools-system (Admin)

```bash
# Unified build (runs all steps)
aegis build                                      # Full build: all steps below
aegis build --dry-run                            # Show what would be done

# Individual build steps (can be run separately)
aegis build-ssh-keys                             # Generate missing SSH keys
aegis build-keytabs                              # Generate missing Kerberos keytabs
aegis build-filesystem-keys                      # Generate missing LUKS keys
aegis build-user-secrets                         # Collect and re-encrypt user secrets
aegis build-bundles                              # Package into host bundles

# Configuration management
aegis init-host <hostname>                       # Add host to src/hosts/
aegis add-secret <hostname> <name> <file>        # Add user-provided secret
aegis add-user <username> --hosts=host1,host2    # Generate keypair, add to config
aegis grant-user-access <username> <hostname>    # Add host to user's access list
aegis revoke-user-access <username> <hostname>

# Role management  
aegis init-role <role> <hostname>                # Create role, assign to host
aegis move-role <role> <from-host> <to-host>

# Utilities
aegis list [hostname]                            # List secrets (all or per-host)
aegis verify <hostname>                          # Verify host can decrypt its bundle
aegis status                                     # Show what needs building
```

### aegis-tools-user (Users)

```bash
# Setup (one-time)
aegis-user init --key=<pubkey-from-admin>     # Store encryption key
aegis-user init --key-file=<path>             # Or read from file

# Add secrets
aegis-user add-env <NAME> <value>             # Add environment variable
aegis-user add-env <NAME> --file=<path>       # Read value from file
aegis-user add-file <name> <file>             # Add arbitrary file

# Management
aegis-user list                               # List all secrets
aegis-user remove <name>                      # Remove a secret
aegis-user edit <name>                        # Re-encrypt with new value
```

User workflow is simple: init once, then `add-env`/`add-file` as needed.
User cannot decrypt their own secrets (by design) - they keep local copies.

## Testing Strategy

### Unit Tests (pytest)

```python
# tests/test_crypto.py
def test_encrypt_decrypt_roundtrip(tmp_path):
    """Encrypt then decrypt returns original content."""
    from aegis.crypto import encrypt_age, decrypt_age, generate_age_keypair
    
    priv, pub = generate_age_keypair()
    content = "secret data"
    encrypted = tmp_path / "secret.age"
    
    encrypt_age(content, [pub], encrypted)
    decrypted = decrypt_age(encrypted, priv)
    
    assert decrypted == content

def test_multi_recipient(tmp_path):
    """Multiple recipients can each decrypt."""
    priv1, pub1 = generate_age_keypair()
    priv2, pub2 = generate_age_keypair()
    
    encrypted = tmp_path / "secret.age"
    encrypt_age("secret", [pub1, pub2], encrypted)
    
    assert decrypt_age(encrypted, priv1) == "secret"
    assert decrypt_age(encrypted, priv2) == "secret"
```

```python
# tests/test_generators.py
def test_ssh_key_generation():
    """Generate valid SSH keypairs."""
    from aegis.generators.ssh import generate_host_keys
    
    keys = generate_host_keys("testhost")
    
    assert keys.host_ed25519.public_key.startswith("ssh-ed25519")
    assert "BEGIN OPENSSH PRIVATE KEY" in keys.host_ed25519.private_key
```

### Integration Tests

```python
# tests/integration/test_workflow.py
@pytest.fixture
def test_repos(tmp_path):
    """Create temporary secrets and entities repos."""
    secrets = tmp_path / "aegis-secrets"
    secrets.mkdir()
    (secrets / "hosts").mkdir()
    
    # Mock entities
    entities = tmp_path / "entities"
    # ... setup mock entity data
    
    return {"secrets": secrets, "entities": entities}

def test_init_host_creates_secrets(test_repos, mock_entities):
    """init-host creates expected secret files."""
    from aegis.cli import init_host
    
    init_host("testhost", 
              secrets_path=test_repos["secrets"],
              entities_path=test_repos["entities"])
    
    host_dir = test_repos["secrets"] / "hosts" / "testhost"
    assert (host_dir / "ssh-keys.age").exists()
```

### NixOS Module Tests

```nix
# tests/module-test.nix
{ pkgs, ... }:

pkgs.nixosTest {
  name = "aegis-secrets-test";
  
  nodes.machine = { config, pkgs, ... }: {
    imports = [ ../module.nix ];
    
    aegis.secrets = {
      enable = true;
      master-key-path = "/tmp/test-master-key";
      
      host-secrets.test-secret = {
        source-file = ./fixtures/test-secret.age;
        target-file = "/run/aegis/test-secret";
      };
    };
  };
  
  testScript = ''
    # Setup: create master key
    machine.succeed("age-keygen -o /tmp/test-master-key")
    
    # Activate and verify
    machine.wait_for_unit("aegis-phase1.target")
    machine.succeed("test -f /run/aegis/test-secret")
    machine.succeed("test $(stat -c %a /run/aegis/test-secret) = 400")
  '';
}
```

## Implementation Phases

### Phase 1: Foundation (Week 1) - DONE
- [x] Create `aegis-tools-system` repo with Python structure
- [x] Implement `crypto.py` (encrypt/decrypt with age)
- [x] Implement `entities.py` (query nix-entities)
- [x] Implement `config.py` (read src/*.toml files)
- [x] Unit tests for crypto and config operations
- [x] Basic CLI skeleton with typer

### Phase 2: Build System (Week 2) - DONE
- [x] `aegis build` - core build command
- [x] `aegis build-ssh-keys` - SSH key generation
- [x] Host bundle generation (build/hosts/<hostname>/)
- [ ] `aegis-secrets` repo structure with src/ and build/
- [x] Integration tests with temp repos

### Phase 3: NixOS Module (Week 3) - DONE
- [x] Implement `aegis.secrets` module
- [x] Read secrets from build/hosts/<hostname>/
- [x] Secret decryption services with two-phase support
- [x] `aegis.autoSecrets` - auto-discovery wrapper
- [x] `aegis.userSecrets` - Home Manager module
- [x] Systemd targets (aegis-phase1, aegis-phase2, aegis-secrets)
- [ ] NixOS VM tests
- [ ] Test deployment to one non-critical host

### Phase 4: Kerberos + Roles (Week 4) - DONE
- [x] `aegis build-keytabs` - Kerberos keytab generation (with Ruby scripts)
- [x] `aegis init-realm` - Initialize new Kerberos realm
- [x] `aegis init-role` - Role key management
- [x] KDC principals file generation for database reconstruction
- [ ] Phase 2 decryption for role secrets (in NixOS module)

### Phase 5: User Secrets (Week 5) - DONE
- [x] `aegis add-user` - create keypair, store private key
- [x] `aegis build-user-secrets` - collect and re-encrypt user secrets
- [x] Create `aegis-tools-user` repo
- [x] `aegis-user init`, `add-env`, `add-file`, `list`, `status` commands
- [ ] User secret decryption in module (phase 2)
- [ ] Home Manager integration

## Kerberos Implementation

Reuses existing battle-tested Ruby scripts from `fudo-secrets` and `fudo-pkgs`:

- `initialize-realm.rb` - Create new realm (master key + initial principals)
- `add-host-to-realm.rb` - Add host principals to realm  
- `instantiate-kerberos-realm.rb` - Reconstruct KDC database from stored principals
- `extract-kerberos-host-keytab.rb` - Extract keytab from reconstructed database

**Storage format** (in aegis-secrets):
```
src/
  kerberos/
    realms/
      FUDO.ORG/
        realm.key.age           # Encrypted realm master key
        principals/
          host_server1.key.age  # Encrypted principal dump lines
          ssh_server1.key.age
          ...
```

**Build process** (`aegis build-keytabs`):
1. Decrypt realm key and all principals to temp directory
2. Run `instantiate-kerberos-realm` to reconstruct database
3. Run `extract-kerberos-host-keytab` for each host  
4. Encrypt keytabs for target hosts + KDC role
5. Clean up temp files

### Phase 5: User Secrets (Week 5)
- [ ] `aegis add-user` - create keypair, add flake input
- [ ] User secret processing in `aegis build`
- [ ] Create `aegis-tools-user` repo
- [ ] `aegis-user init`, `add-env`, `add-file` commands
- [ ] User secret decryption in module (phase 2)
- [ ] Home Manager integration

### Phase 6: Migration (Week 6-7)
- [ ] Migrate secrets host-by-host
- [ ] Run parallel with old system
- [ ] Verify each host before continuing
- [ ] Remove old system after verification

## File Format

Secrets stored as age-encrypted YAML:

```yaml
# hosts/nostromo/ssh-keys.age (after decryption)
host:
  ed25519:
    private: |
      -----BEGIN OPENSSH PRIVATE KEY-----
      ...
    public: ssh-ed25519 AAAA... host@nostromo
  ecdsa:
    private: |
      ...
    public: ecdsa-sha2-nistp256 AAAA... host@nostromo
deploy:
  ed25519:
    private: |
      ...
    public: ssh-ed25519 AAAA... deploy@nostromo
```

```yaml
# hosts/nostromo/keytab.age (after decryption)
realm: FUDO.ORG
host: nostromo.fudo.org
keytabs:
  host: |
    <base64-encoded keytab>
  ssh: |
    <base64-encoded keytab>
```

## Encryption Patterns

### Host Secret
Recipients: host master-key + admin key
```
aegis add-secret nostromo api-token ./token.txt
  -> encrypts for: [nostromo-master-key, admin-key]
  -> writes: hosts/nostromo/api-token.age
```

### Role-Accessible Secret (keytab)
Recipients: host master-key + role key + admin key
```
aegis make-keytab nostromo
  -> encrypts for: [nostromo-master-key, kdc-role-key, admin-key]
  -> writes: hosts/nostromo/keytab.age
```

### User Secret (in user's repo)
Recipients: user repo public key (given by admin)
```
aegis-user add-env GITHUB_TOKEN ghp_xxx
  -> encrypts for: [niten-repo-pubkey]
  -> writes: aegis-secrets-niten/env/GITHUB_TOKEN.age
```

### User Secret (after build)
Recipients: specific host master-key + admin key
```
aegis build
  -> decrypts aegis-secrets-niten/env/GITHUB_TOKEN.age
  -> for each host niten can access:
     -> encrypts for: [<host>-master-key, admin-key]
     -> writes: build/hosts/<host>/users/niten/env.age
```

## Directory Layout

### aegis-secrets/ (Central Repo - Admin Controlled)

```
aegis-secrets/
  flake.nix                 # inputs: user repos, nix-entities
  
  # Source secrets (input to build)
  src/
    hosts/
      nostromo.toml         # host config: services, filesystem keys, etc.
      legatus.toml
    domains/
      fudo.org.toml         # domain config: realm settings
    roles/
      kdc.toml              # role -> host mapping
      dns.toml
    users/
      niten.toml            # user config: hosts list, repo URL
      alice.toml
  
  # Keys for decrypting user repos (encrypted for admin)
  keys/
    users/
      niten.age             # private key to decrypt niten's repo
      alice.age
    admin.pub               # admin's public key
  
  # Build output (generated by `aegis build`)
  build/
    hosts/
      nostromo/
        ssh-keys.age        # encrypted for nostromo's master-key
        keytab.age
        filesystem-keys.age
        users/
          niten/
            env.age         # niten's env vars for this host
            files.age
      legatus/
        ...
    domains/
      fudo.org/
        realm-master-key.age
        dnssec.age
    roles/
      kdc.age
      dns.age
```

### aegis-secrets-niten/ (User Repo - User Controlled)

```
aegis-secrets-niten/
  .key                      # public key (given by admin)
  env/
    GITHUB_TOKEN.age        # encrypted for central repo to decrypt
    OPENAI_API_KEY.age
  files/
    aws-credentials.age
```

## Dependencies

Python:
- `typer` - CLI framework
- `pyyaml` - YAML handling
- `pytest` - testing

System (via Nix):
- `age` - encryption
- `ssh-keygen` - SSH key generation
- `ssh-to-age` - convert SSH keys to age keys

## Migration from fudo-secrets

1. Deploy aegis module alongside existing `fudo.secrets`
2. Migrate one host at a time:
   - Generate encrypted secrets with aegis tools
   - Add `aegis.secrets.host-secrets` config
   - Deploy, verify secrets decrypt
   - Remove from old `fudo.secrets.host-secrets`
3. After all hosts migrated, remove `fudo.secrets` module
4. Archive old fudo-secrets repo

## Success Criteria

- [ ] All secrets encrypted at rest
- [ ] Build server never sees plaintext
- [ ] Secrets decrypt correctly on target hosts
- [ ] Two-phase decryption works (roles, users)
- [ ] Users can self-manage secrets
- [ ] Comprehensive test coverage
- [ ] Migration completes without downtime
